---
layout:     post
title:      Django基础（二）
subtitle:   今天是在models.py建立基础的数据表。由于我想直接上手MySQL，所以今天开始切换到MySQL数据库，其实除了配置，其他都是一样的，后面就不用sqlite3了。
date:       2019-12-18
author:     HouKC
header-img: img/post-bg-coffee.jpeg
catalog:    true
tags:
    - Django
    - Python
    - 后端
---

## 前言
Django基础我也是学了点基础，现在边学边做，所以无法一步到位实现完整的网站，一开始只是一点简陋界面实现一点简单的功能，越到后面越来越完善。

今天先切换MySQL数据库，后面就不打算继续用Sqlite3数据库了；然后是models.py建立基础数据表，数据表目前也不是最全的，后续慢慢跟进项目接着完善。

## 1. 配置MySQL数据库
#### 1.1 安装MySQL数据库并启动服务
这里就不多赘述了，安装完成后注意启动MySQL服务。

然后命令行进入到MySQL，创建一个名为blog的数据库。

#### 1.2 修改settings.py配置
注释掉原来的Sqlite3配置，添加新的配置如下：
```python
# DATABASES = {
#     'default': {
#         'ENGINE': 'django.db.backends.sqlite3',
#         'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
#     }
# }
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'blog',
        'USER': 'root',
        'PASSWORD': '123456789',
        'HOST': 'localhost',
        'PORT': '3306',
    }
}
```
其中USER是MySQL账号名，NAME是数据库名，PASSWORD是MySQL密码，其他不用修改。

然后在/myblog/myblog/\_\_init__.py文件中写入以下两行代码：
```python
import pymysql
pymysql.install_as_MySQLdb()
```

#### 1.3 创建数据表和超级用户
在命令行移动到项目路径下/myblog，输入以下命令创建数据表和超级用户：
```sh
python manage.py migrate
python manage.py createsuperuser
```

#### 1.4 删除原来生成的db.sqlite3文件
由于Django默认连接Sqlite3，所以上次执行了migrate命令后会生成db.sqlite3，连接了MySQL之后这个就没用了，可以删除掉。

## 2. 创建博客项目的数据表
#### 2.1 导入封装库
首先是导入相关库
```python
from django.db import models
from django.utils import timezone
from django.core.urlresolvers import reverse
```
models是模型标准库；timezone为时区库，用于获取时间，这个时间跟settings.py中设置的时区有关；
reverse用于模型创建时跳转到对应的视图函数所用，在models.py中一般跟get_absolute_url()函数一起用，
比如在创建一个博客对象后，需要自动跳转到对应的博客页面中去，这时就可以使用reverse和get_absolute_url()了。

#### 2.2 用户表类User
```python
class User(models.Model):  # 用户表类
    name = models.CharField('用户名', max_length=20, null=False)  # 用户名
    password = models.CharField('密码', max_length=20, null=False)  # 密码
    email = models.EmailField('邮箱')     # 电子邮箱
    enabled = models.BooleanField(default=False)  # 是否登录，默认否

    def __str__(self):  # 设置输出User对象时的内容，也就是print(User对象)就会显示的内容
        return self.name
```
User表包含四个字段：name、password和enabled，分别存储用户名、密码、邮箱和登录状态。

#### 2.3 标签表类Tag
```python
class Tag(models.Model):    # 标签表类
    name = models.CharField(max_length=80)  # 标签名
    created_time = models.DateTimeField(auto_now_add=True)  # 标签创建时间

    class Meta:
        ordering = ['created_time']     # 根据创建tag的时间排序

    def __str__(self):
        return self.name
```
Tag表包含两个字段：name和created_time，分别存储标签名和标签创建时间，同时限定了tag类的所有对象根据创建时间排序。

#### 2.4 自定义博客表类的筛选器PublishedManager
```python
class PublishedManager(models.Manager):
    def get_queryset(self):
        return super(PublishedManager, self).get_queryset().filter(status='published')
```
这里定义了一个筛选器，可以筛选出所有字段status值为published的对象，这里是针对下面将要说的Post博客表类。

#### 2.5 博客表类Post
```python
class Post(models.Model):  # 博客表类
    choices = (
        ('draft', '草稿'),
        ('published', '发表'),
    )

    title = models.CharField('标题', max_length=200, unique=True)  # unique表示标题唯一
    slug = models.SlugField('简介', max_length=250)
    author = models.ForeignKey(User, verbose_name='作者', on_delete=models.CASCADE, related_name="author_posts")  # 外键关联User类，别名为"作者"，删除该对象时也删除与User的关联，related_name是支持反向搜索，允许通过作者搜索其所有文章
    body = models.TextField('正文')
    published_time = models.DateTimeField('发表时间', default=timezone.now, null=True)  # 发布时间可以为空，默认为当前时间
    created_time = models.DateTimeField('创建时间', auto_now_add=True)  # 创建时间自动生成，并且仅生成一次
    updated_time = models.DateTimeField('修改时间', auto_now=True)  # 更新时间自动追加
    status = models.CharField('文章状态', max_length=1, choices=choices, default='published')  # 表示文章发表或者是草稿状态，默认发表，choices是替换了显示该字段时的字符
    tags = models.ManyToManyField('Tag', verbose_name='标签', blank=True)  # 标签是多对多
    views = models.PositiveIntegerField('浏览量', default=0)  # 浏览量为正整数，从0开始
    likenum = models.PositiveIntegerField('点赞', default=0)  # 点赞数

    objects = models.Manager()  # 默认的筛选器
    published = PublishedManager()  # 自定义筛选器，调用这个对象时会得到已经发表了的博客

    def __str__(self):
        return self.title

    def viewed(self):  # 浏览量自加1的函数
        self.views += 1
        self.save(update_fields=['views'])

    class Meta:
        ordering = ['-published_time']  # 按照发布时间从大到小排序
        verbose_name = "博客"  # 设置后台管理显示的字符
        verbose_name_plural = verbose_name  # 复数和单数显示的字符一致
```
这个类稍微复杂一点，choices是用于在显示status字段时的字符，做一个转换。基本上囊括了整个博客的内容：标题、简介、作者、正文、
发表时间、创建时间、修改时间、文章状态（草稿/发表）、标签、浏览量和点赞数。其实还有评论，但是评论可以通过下面的Comment类来反向搜索。

objects和published两个筛选器，一个是默认的，一个是上面设置的状态筛选器，之后再views.py中调用的话可以帮我们过滤掉草稿，只留下发表了的博客。

viewed()函数是用于浏览量自加1，可以在views.py中调用。

Meta参数中ordering设置博客默认按照发布时间从大到小排序。verbose_name是显示表类名为“博客”，verbose_name_plural表示该表类的对象超过1个时，也就是复数，显示表类名也为“博客”。

#### 2.6 评论表类
```python
class Comment(models.Model):    # 评论表类
    post = models.ForeignKey(Post, related_name='post_comments')     # 支持反向搜索，通过博客内容搜索该博客下的所有评论
    name = models.CharField(max_length=80)  # 评论用户的名称
    body = models.TextField()   # 评论内容
    created_time = models.DateTimeField(auto_now_add=True)   # 评论时间
    updated_time = models.DateTimeField(auto_now=True)  # 评论更新时间
    active = models.BooleanField(default=True)  # 评论激活状态，默认激活

    def __str__(self):  # 显示由谁对什么博客的评论
        return 'Comment by {} on {}'.format(self.name, self.post)

    class Meta:
        ordering = ['-created_time']
```
这里设计的评论只能关联博客，也就是说只能发评论...没办法回复评论（技术有限，逻辑没有构思好，后续修改）。

## 后记
下一章准备写一点views.py，构建基本的路由urls.py，同时创建templates文件夹，导入bootstrap和jQuery。

另外，再把models模型的一些相关知识点补充一个笔记上来，稍微巩固一下吧哈哈哈~快忘完了。

参考：

[Django基础(6): 模型Models高级进阶必读。](https://mp.weixin.qq.com/s?__biz=MjM5OTMyODA4Nw==&mid=2247483893&idx=1&sn=3554413878374aaf95631093d5849cb2&chksm=a73c61cd904be8db56032d32654aca4374fb403e95d949f52a9a3ee57718a9e8641536c15206&scene=21#wechat_redirect)