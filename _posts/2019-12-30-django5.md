---
layout:     post
title:      Django基础（五）
subtitle:   停更一周，主要学习了用户认证django-allauth库，主要写一下博客网站views.py中的编写，使用一些通用视图类，通过修改其中的方法，或者加一些修饰器来实现目标视图。还有利用bootstrap做一点修改美化。还没有完全完善，仅仅记录一下过去一周的学习进展，理解还不够深刻。
date:       2019-12-30
author:     HouKC
header-img: img/post-bg-coffee.jpeg
catalog:    true
tags:
    - Django
    - Python
    - 后端
---

## 前言
前面说到建了一个base.html页面的模板，接下来会先根据那个基础模板，创建一系列页面。当然，页面内部暂时先不做具体设计。

然后我们接着models.py编写之后，继续来完成一些View的编写。

完成了Model的设计，我们在views.py中做一些视图函数，去调用这些模型提取数据，处理好然后嵌入到模板Template中，
之后我们再分配路由url给到这些视图函数。

## 步骤
#### 1. 创建一系列待用页面html

我们将会用到至少以下这些模板：

- 首页：index.html
- 我的主页：myblog.html
- 博客列表页：post_list.html
- 博客详情页：post_detail.html
- 草稿箱列表页：post_draft_list.html
- 已发表博客列表页：post_published_list.html
- 添加博客页：post_create_form.html
- 更新博客页：post_update_form.html
- 类别列表页：category_list.html
- 类别详情页：category_detail.html
- 标签列表页：tag_list.html
- 标签详情页：tag_detail.html
- 搜索页：post_search.html

在templates文件夹下创建blog文件夹，把base.html放在blog文件夹下，并在blog中创建上述文件，在每个文件中都写入以下代码：
<!-- {% raw %} -->
```html
{% extends "blog/base.html" %}
{% block title %}博客{% endblock %}
{% block body %}<p>test</p>{% endblock %}
```
<!-- {% endraw %} -->
这样一来，我们就可以在views视图中暂时调用这些html文件了，后续再逐步更新优化相应的视图、路由和模板，这里先用简单的文件代替。

但是，由于我们在使用博客系统的时候，有些页面只能有用户权限才能访问，也就是我们还要在原
有基础上增加用户登录等操作，于是这里插入一点用户认证的知识，用到的库是django-allauth。

在此之前我们先建立好用户模型，我们将借助Django自带的User类来建立用户模型。

#### 2. 建立用户Model
在models.py中添加以下代码：
```python
from django.db import models
from django.utils import timezone
from django.template.defaultfilters import slugify
from django.urls import reverse
from unidecode import unidecode
from django.contrib.auth.models import User
from allauth.account.models import EmailAddress

class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')
    org = models.CharField('组织', max_length=128, blank=True)
    telephone = models.CharField("电话", max_length=50, blank=True)
    last_mod_time = models.DateTimeField('最近更新时间', auto_now=True)

    def __str__(self):
        return "%s的个人信息" % self.user.__str__()

    def account_verified(self):
        if self.user.is_authenticated:
            result = EmailAddress.objects.filter(email=self.user.email)
            if len(result):
                return result[0].verified
        return False

    class Meta:
        verbose_name = '用户个人信息'
        verbose_name_plural = verbose_name
```
这个类会一对一绑定User类，account_verified()函数用于判断用户邮箱是否已验证。由于User类
只有5个字段如first_name、last_name、email...我们实际上还会有手机啊、公司啊之类的信息，
因此需要对原有User类进行拓展。

同时还要重写用户登录表单。因为django-allauth在用户注册只会创建User对象，不会创建与之关
联的UserProfile对象，而我们需要用户在注册时两个对象必须同时都创建，并存储到数据库中。

#### 3. 添加表单forms.py
我们在blog文件夹下创建一个forms.py文件，用来存放所需的各种表单。
以下是forms.py中的内容：
```python
from django import forms

class ProfileForm(forms.Form):
    first_name = forms.CharField(label='姓氏', max_length=50, required=False)
    last_name = forms.CharField(label='名字', max_length=50, required=False)
    org = forms.CharField(label='组织', max_length=50, required=False)
    telephone = forms.CharField(label='电话', max_length=50, required=False)

class SignupForm(forms.Form):
    def signup(self, request, user):
        user_profile = UserProfile()
        user_profile.user = user
        user.save()
        user_profile.save()
```
第一个表单是提供用户提交修改信息的表单，第二个表单是新用户注册时，除了Django自动创建User对象外，
我们还要同时创建一个与之相关联的UserProfile对象。

SignupForm表单类将在后面django-allauth库安装完成的时候添加使用，
届时需要在settings.py中增加一个参数来调用这个表单类

完了之后光创建了用户模型类和表单类是没用的，还得有人来帮我们处理用户注册登录和验证的流程，于是
我们用django-admin来做这件事。

#### 4. 添加django-allauth库
在命令行输入以下命令：
```sh
pip install django-allauth
```
安装完成后，找到安装路径（我的是安装在虚拟环境venv中的这里 E:\workspace\python_workspace\venv\Lib\site-packages\allauth\templates\account），
把整个account文件夹复制到myblog/templates/文件夹下。

#### 5. 在settings.py中配置allauth
接着修改settings.py，注册allauth相关app，同时还要设置SITE_ID=1：
```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'blog',

    # allauth相关app的注册
    'django.contrib.sites',
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.github',   # 用于GitHub第三方平台登录接口
    'allauth.socialaccount.providers.baidu',    # 用于百度第三方平台登录接口
]
SITE_ID = 1
```
注：我们要注意在之前我们就在settings.py中修改了TEMPLATES的DIRS参数，也就
是templates文件夹的路径。如果没有设置，那么默认allauth会找到安装路径下的account文
件夹中的模板，但是现在我们设置了这个参数，所以前面才会要把account整个文件夹复制过来。

接下来settings.py还有一些邮箱认证的设置：
```python
# allauth设定
ACCOUNT_AUTHENTICATION_METHOD = 'username_email'
ACCOUNT_EMAIL_REQUIRED = True
LOGIN_REDIRECT_URL = '/profile/'    # '/'
ACCOUNT_LOGOUT_REDIRECT_URL = '/accounts/login/'

AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend',
    'allauth.account.auth_backends.AuthenticationBackend',
)

# 设置邮箱
EMAIL_HOST = 'smtp.qq.com'
EMAIL_PORT = 25   # 三个中的一个：25，465，587
EMAIL_HOST_USER = 'xxxx@xxx.com'   # 你的QQ邮箱
EMAIL_HOST_PASSWORD = 'xxxxxxxxxxx'     # 授权码，在邮箱中可以获得（自行百度）
EMAIL_USE_TLS = True    # 这里必须是 True，否则发送不成功
EMAIL_FROM = 'xxxx@xxx.com'    # 你的QQ邮箱
DEFAULT_FROM_EMAIL = 'xxxx@xxx.com'     # 邮件中注明出处用的，随便显示就行

# 设置allauth使用自定义的注册表单
ACCOUNT_SIGNUP_FORM_CLASS = 'blog.forms.SignupForm'
```
这里的ACCOUNT_SIGNUP_FORM_CLASS参数就是前面第3点我们说到的：SignupForm表单类添加使用
需要在settings.py中增加一个参数来调用这个表单类。

另外，allauth可配置项如下表：

参数|默认值或可选值|说明
---|---|---
ACCOUNT_AUTHENTICATION_METHOD|"username" or "email" or "username_email"|指定要使用的登录方法（用户名、电子邮件地址或两者之一）
ACCOUNT_EMAIL_REQUIRED|True|为True时要求登录时一定要输入邮箱
ACCOUNT_EMAIL_CONFIRMATION_EXPIRE_DAYS|3|邮件确认邮件的截止日期(天数)
ACCOUNT_EMAIL_VERIFICATION|"optional"|注册中邮件验证方法:“强制（mandatory）”,“可选（optional）”或“否（none）”之一
ACCOUNT_EMAIL_CONFIRMATION_COOLDOWN|180|邮件发送后的冷却时间(以秒为单位)
ACCOUNT_LOGIN_ATTEMPTS_LIMIT|5|登录尝试失败的次数
ACCOUNT_LOGIN_ATTEMPTS_TIMEOUT|300|从上次失败的登录尝试，用户被禁止尝试登录的持续时间
ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION|False|更改为True，用户一旦确认他们的电子邮件地址，就会自动登录
ACCOUNT_LOGOUT_ON_PASSWORD_CHANGE|False|更改或设置密码后是否自动退出
ACCOUNT_LOGIN_ON_PASSWORD_RESET|False|更改为True，用户将在重置密码后自动登录
ACCOUNT_SESSION_REMEMBER|None|控制会话的生命周期，可选项还有:False,True
ACCOUNT_SIGNUP_EMAIL_ENTER_TWICE|False|用户注册时是否需要输入邮箱两遍
ACCOUNT_SIGNUP_PASSWORD_ENTER_TWICE|True|用户注册时是否需要用户输入两遍密码
ACCOUNT_USERNAME_BLACKLIST|[]|用户不能使用的用户名列表
ACCOUNT_UNIQUE_EMAIL|True|加强电子邮件地址的唯一性
ACCOUNT_USERNAME_MIN_LENGTH|1|用户名允许的最小长度的整数
SOCIALACCOUNT_AUTO_SIGNUP|True|使用从社会帐户提供者检索的字段(如用户名、邮件)来绕过注册表单
LOGIN_REDIRECT_URL|"/"|设置登录后跳转链接
ACCOUNT_LOGOUT_REDIRECT_URL|"/"|设置退出登录后跳转链接

#### 6. 配置路由urls.py
配置完了之后，网站发生了什么呢？我们可以设置一点视图，来显示我们安装配置allauth之后发生的变化。
首先打开myblog/urls.py设置一下路由：
```python
from django.contrib import admin
from django.urls import path, include
from django.conf.urls.static import static
from django.conf import settings

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('allauth.urls')),
    path('', include('blog.urls')),
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```
把allauth.urls添加进来，顺便把MEDIA_URL也设置一下，可能以后上传图片什么的会用到。

接着是blog/urls.py，修改如下：
```python
from django.urls import path, re_path
from . import views
app_name = 'blog'
urlpatterns = [
    re_path(r'^profile/$', views.profile, name='profile'),
    re_path(r'^profile/update/$', views.profile_update, name='profile_update'),
]
```

#### 7. 配置视图views.py
然后打开views.py修改如下：
```python
from django.shortcuts import render, get_object_or_404
from django.http import HttpResponseRedirect
from django.urls import reverse
from .models import UserProfile
from .forms import ProfileForm
from django.contrib.auth.decorators import login_required   # 登录装饰器

# 登录后主页
@login_required
def profile(request):
    user = request.user
    return render(request, 'account/profile.html', {'user': user})

# 登录后更新个人信息页
@login_required
def profile_update(request):
    user = request.user
    user_profile = get_object_or_404(UserProfile, user=user)

    if request.method == 'POST':
        form = ProfileForm(request.POST)
        if form.is_valid():
            user.first_name = form.cleaned_data['first_name']
            user.last_name = form.cleaned_data['last_name']
            user.save()

            user_profile.org = form.cleaned_data['org']
            user_profile.telephone = form.cleaned_data['telephone']
            user_profile.save()

            return HttpResponseRedirect(reverse('blog:profile'))
    else:
        default_data = {'first_name': user.first_name, 'last_name': user.last_name,
                        'org': user_profile.org, 'telephone': user_profile.telephone}
        form = ProfileForm(default_data)

    return render(request, 'account/profile_update.html', {'form': form, 'user': user})
```
login_required是装饰器，经过装饰之后的视图函数都会去验证是否为用户登录状态，不是的话会跳转到登录页。




## 后记
这可能是我写的最长的一篇博客了，其实内容很乱，主要是记录过去一周我对博客系统这个项目
的进度，对学习内容的一点思考以及一些学习记录。

到目前为止，稍微动过刀的就有base.html、index.html、myblog.html、post_create_form.html。
没有动过刀的还有很多，包括templates/account/文件夹下的模板，还有一些static/下的css、js文件。

整体实现了用户注册登录验证，简单的views.py视图逻辑，首页主页登录页注册页的一些跳转，
仅提供了按键。很多东西还没有显示出来，还有很多没有考虑到正在构思中的东西，比如点赞、
评论功能、搜索功能、时间分类、推荐算法等。url跳转也比较混乱，没有规划好，在过去一周
中重新构思了很多，原本只是想做一个简单的个人博客，现在引入了用户注册之后想上升为博客
系统或者博客平台。

另外，目前bootstrap不熟，Django很多类的内置方法没有系统地整理出来，我打算接下来把模
型、视图、模板的一些类方法整理一下。

还有慢慢接触一点设计模式，数据库，缓存，消息队列，服务器，序列化，前后端解耦的后
端（Django-Rest-Framework框架）。

参考：

[Python Web与Django开发必读](https://blog.csdn.net/weixin_42134789/article/details/100035449)

[刘江的Django教程](http://www.liujiangblog.com/course/django/)